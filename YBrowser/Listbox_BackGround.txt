
void CMyListItemDrawer::DrawActualItem(TInt aItemIndex,
const TRect& aActualItemRect, TBool aItemIsCurrent,
TBool /*aViewIsEmphasized*/, TBool /*aViewIsDimmed*/,
TBool aItemIsSelected) const
{
const MDesCArray* itemArray = iListBox.Model()->ItemTextArray();
if ((!itemArray) || (itemArray->MdcaCount() <= aItemIndex))
return;

// Gets the item text if the conditions above are met.
TPtrC itemText = itemArray->MdcaPoint(aItemIndex);

// We have to find the position of tabs to decide the components
// available in the item text (icon, heading and text).
TInt tabPosition1 = itemText.Locate('\t');
TInt tabPosition2 = itemText.Mid(tabPosition1 + 1).Locate('\t');
if (tabPosition2 >= 0)
{
// We need to add tabPosition1 because the return value of
// Locate() is relative to tabPosition1.
tabPosition2 += tabPosition1 + 1;
}

// Sets the attributes to draw the icon.

if ((aItemIsCurrent) || (aItemIsSelected))
{
iGc->SetBrushColor(iHighlightedBackColor);
iGc->SetBrushStyle(CGraphicsContext::ESolidBrush);
}
else
{
iGc->SetBrushColor(iBackColor);
iGc->SetBrushStyle(CGraphicsContext::ENullBrush);
}

// Gets the icon index, i.e. the number in the text item before
// the first tab.
TInt iconIndex = 0;
if (tabPosition1 > 0)
{
TLex(itemText.Mid(0, tabPosition1)).Val(iconIndex);
}
if ((iIconArray) && (iIconArray->Count() > iconIndex)
&& (tabPosition1 > 0))
{
// Draws the icon.
CFbsBitmap* bitmap = (*iIconArray)[iconIndex]->Bitmap();
iGc->BitBltMasked(TPoint(aActualItemRect.iTl.iX,aActualItemRect.iTl.iY+6),//conan modify
bitmap,
TRect(TPoint(0, 0), bitmap->Header().iSizeInPixels),
(*iIconArray)[iconIndex]->Mask(),
ETrue);

// Draws the rectangle, just in case there are some icons that are
// smaller than the height of item width and/or height.
iGc->SetPenStyle(CGraphicsContext::ENullPen);
if (bitmap->Header().iSizeInPixels.iWidth < aActualItemRect.Height())
{
TRect rect = TRect(
aActualItemRect.iTl.iX,
aActualItemRect.iTl.iY+2,
aActualItemRect.iTl.iX + bitmap->Header().iSizeInPixels.iWidth,
aActualItemRect.iTl.iY + 6);
iGc->DrawRect(rect);
}

if (bitmap->Header().iSizeInPixels.iHeight < aActualItemRect.Height())
{
TRect rect(
aActualItemRect.iTl.iX,
aActualItemRect.iTl.iY +6 + bitmap->Header().iSizeInPixels.iHeight,
aActualItemRect.iTl.iX + iMaxIconSize.iWidth,
aActualItemRect.iBr.iY-2);//conan modify
iGc->DrawRect(rect);
}

if (bitmap->Header().iSizeInPixels.iWidth < iMaxIconSize.iWidth)
{
TRect rect = TRect(
aActualItemRect.iTl.iX + bitmap->Header().iSizeInPixels.iWidth,
aActualItemRect.iTl.iY + 2,
aActualItemRect.iTl.iX + iMaxIconSize.iWidth,
aActualItemRect.iBr.iY - 2);
iGc->DrawRect(rect);
}
}
else
{
iGc->SetPenStyle(CGraphicsContext::ENullPen);
TRect rect(
aActualItemRect.iTl.iX,
aActualItemRect.iTl.iY +2 ,
aActualItemRect.iTl.iX + iMaxIconSize.iWidth,
aActualItemRect.iBr.iY -2 );
iGc->DrawRect(rect);
}

// Sets the attributes to draw text, except the font.
const CFont* font = Font(aItemIndex);


if ((aItemIsCurrent) || (aItemIsSelected))
{
iGc->SetPenStyle(CGraphicsContext::ESolidPen);
iGc->SetPenColor(iHighlightedTextColor);
iGc->SetBrushColor(iHighlightedBackColor);
iGc->SetBrushStyle(CGraphicsContext::ESolidBrush);
}
else
{
iGc->SetPenStyle(CGraphicsContext::ESolidPen);
iGc->SetPenColor(iTextColor);
iGc->SetBrushColor(iBackColor);
iGc->SetBrushStyle(CGraphicsContext::ENullBrush);
}

// If there is only one tab, it means we have to display single line item
if (tabPosition2 < 0)
{
if (!font)
{
font = CEikonEnv::Static()->LegendFont();//AnnotationFont();//TitleFont();
}
iGc->UseFont(font);
TRect textRect(
TPoint(aActualItemRect.iTl.iX + iMaxIconSize.iWidth,
aActualItemRect.iTl.iY + 2),
TPoint(aActualItemRect.iBr.iX, aActualItemRect.iBr.iY-2));
TInt baseline =
(textRect.iBr.iY - textRect.iTl.iY - font->HeightInPixels()) / 2
+ font->AscentInPixels();

if (tabPosition1 < 0)
{
iGc->DrawText(itemText, textRect, baseline,
CGraphicsContext::ELeft, 1);
}
else
{
iGc->DrawText(itemText.Mid(tabPosition1 + 1), textRect, baseline,
CGraphicsContext::ELeft, 1);
}
}

else
{
// If there are more than one tab, then we have to display double line
// item text
TRect textRect(
TPoint(aActualItemRect.iTl.iX + iMaxIconSize.iWidth,
aActualItemRect.iTl.iY+2),
TPoint(aActualItemRect.iBr.iX, aActualItemRect.iBr.iY-2));
textRect.iBr.iY -= aActualItemRect.Height() / 2;

// Draws the first line.
if (!font)
{
font = CEikonEnv::Static()->LegendFont();
}
iGc->UseFont(font);
TInt baseline =
(textRect.iBr.iY - textRect.iTl.iY - font->HeightInPixels()) / 2
+ font->AscentInPixels();
iGc->DrawText(
itemText.Mid(tabPosition1 + 1, tabPosition2 - tabPosition1 - 1),
textRect, baseline, CGraphicsContext::ELeft, 1);

// Draws the second line. For the second line, we use normal font.
font = CCoeEnv::Static()->NormalFont();
iGc->UseFont(font);
textRect.Move(0, aActualItemRect.Height() / 2 - 2);//conan modify
baseline =
(textRect.iBr.iY - textRect.iTl.iY - font->HeightInPixels()) / 2
+ font->AscentInPixels();
iGc->DrawText(itemText.Mid(tabPosition2 + 1), textRect, baseline,
CGraphicsContext::ELeft, 1);
}

}
Reply With Quote